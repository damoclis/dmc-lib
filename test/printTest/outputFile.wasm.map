{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","../../lib/constant.ts","../../src/asset.ts","~lib/arraybuffer.ts","~lib/rt/stub.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/util/string.ts","~lib/typedarray.ts","../../src/contract.ts","../../src/address.ts","../../src/action.ts","~lib/bytes.ts","~lib/utf8util.ts","~lib/datastream.ts","~lib/string.ts","index.ts","../../lib/helper.ts","../../src/print.ts","../../lib/codec.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Value is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Value is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","export const SHA256_LEN = 32;\nexport const SHA512_LEN = 64;\nexport const RIPEMD160_LEN = 20;\nexport const ADDRESS_LEN = 20;\nexport const SIGNATURE_LEN = 64;\nexport const PUBLIC_KEY_LEN = 32;\n","import { Builtin } from \"./action\";\nimport { SafeMath } from \"../lib/safeMath\";\n\nexport const UNIT = 0x0\nexport const KUNIT = 0x1\nexport const MUNIT = 0X2\nexport const DOM = 0x3\n\nexport class Asset implements Serializable {\n\n    amount: u64;\n    symbol: u8;\n\n    constructor(amt: u64 = 0, sy: u8 = DOM) {\n        this.amount = amt;\n        this.symbol = sy;\n    }\n\n    bytes(): Bytes {\n        const raw = this.raw();\n        return Builtin.fromU64(this.amount).bytes();\n    }\n\n    raw(): u64 {\n        let amount = this.amount\n        if (this.symbol == KUNIT) {\n            amount *= 1000\n        } else if (this.symbol == MUNIT) {\n            amount *= 1000 * 1000\n        } else if (this.symbol == DOM) {\n            amount *= 1000 * 1000 * 100\n        }\n        return amount\n    }\n\n    isSymbolValid(): bool {\n        return this.symbol == UNIT || this.symbol == KUNIT || this.symbol == MUNIT || this.symbol == DOM;\n    }\n\n    //算数操作\n    @operator(\">\")\n    gt(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount > r.amount;\n    }\n\n    @operator(\">=\")\n    gte(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount >= r.amount;\n    }\n\n    @operator(\"<\")\n    lt(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount < r.amount;\n    }\n\n    @operator(\"<=\")\n    lte(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount <= r.amount;\n    }\n\n    @operator(\"==\")\n    eq(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount == r.amount;\n    }\n\n    @operator(\"!=\")\n    uq(r: Asset): bool {\n        return this.symbol == r.symbol && this.amount != r.amount;\n    }\n\n    @operator(\"+\")\n    add(r: Asset): Asset {\n        assert(r.symbol == this.symbol, \"Asset with different symbols!\");\n        this.amount = SafeMath.add(this.amount , r.amount);\n        return this;\n    }\n    \n    @operator(\"-\")\n    sub(r: Asset): Asset {\n        assert(r.symbol == this.symbol, \"Asset with different symbols!\");\n        assert(r.amount <= this.symbol, \"Asset amount not enough!\");\n        this.amount = SafeMath.sub(this.amount , r.amount);\n        return this;\n    }\n\n    @operator(\"*\")\n    multi(r: u64): Asset {\n        this.amount = SafeMath.mul(this.amount , r);\n        return this;\n    }\n    \n    @operator(\"/\")\n    divide(r: u64): Asset {\n        this.amount = SafeMath.div(this.amount , r);\n        return this;\n    }\n\n\n    //Serilizable interface implements\n    serialize(ds: DataStream): void {\n        ds.write<u64>(this.amount);\n        ds.write<u8>(this.symbol);\n    }\n\n    deserialize(ds: DataStream): void {\n        this.amount = ds.read<u64>();\n        this.symbol = ds.read<u8>();\n    }\n\n    key(): string {\n        return \"\";\n    }\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  @unsafe data: ArrayBuffer;\n  @unsafe dataStart: usize;\n  @unsafe dataLength: u32;\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.data = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.dataLength = length;\n  }\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.data));\n  }\n\n  get byteLength(): i32 {\n    return this.dataLength;\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (value) {\n      if (value instanceof Int8Array) return true;\n      if (value instanceof Uint8Array) return true;\n      if (value instanceof Uint8ClampedArray) return true;\n      if (value instanceof Int16Array) return true;\n      if (value instanceof Uint16Array) return true;\n      if (value instanceof Int32Array) return true;\n      if (value instanceof Uint32Array) return true;\n      if (value instanceof Int64Array) return true;\n      if (value instanceof Uint64Array) return true;\n      if (value instanceof Float32Array) return true;\n      if (value instanceof Float64Array) return true;\n      if (value instanceof DataView) return true;\n    }\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { AL_MASK, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\n\n// @ts-ignore: decorator\n@lazy\nvar startOffset: usize = (__heap_base + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@lazy\nvar offset: usize = startOffset;\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize, id: u32): usize {\n  if (size > BLOCK_MAXSIZE) unreachable();\n  var ptr = offset + BLOCK_OVERHEAD;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newPtr;\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  block.rtId = id;\n  block.rtSize = size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ref: usize, size: usize): usize {\n  var block = changetype<BLOCK>(ref - BLOCK_OVERHEAD);\n  var oldSize = <usize>block.rtSize;\n  if (size > oldSize) {\n    let newRef = __alloc(size, block.rtId);\n    memory.copy(newRef, ref, oldSize);\n    ref = newRef;\n  } else {\n    block.rtSize = size;\n  }\n  return ref;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nfunction __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ref: usize, cookie: u32): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    let w: u32, x: u32;\n\n    // copy 1 byte each until src is aligned to 4 bytes\n    while (n && (src & 3)) {\n      store<u8>(dest++, load<u8>(src++));\n      n--;\n    }\n\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\n    if ((dest & 3) == 0) {\n      while (n >= 16) {\n        store<u32>(dest     , load<u32>(src     ));\n        store<u32>(dest +  4, load<u32>(src +  4));\n        store<u32>(dest +  8, load<u32>(src +  8));\n        store<u32>(dest + 12, load<u32>(src + 12));\n        src += 16; dest += 16; n -= 16;\n      }\n      if (n & 8) {\n        store<u32>(dest    , load<u32>(src    ));\n        store<u32>(dest + 4, load<u32>(src + 4));\n        dest += 8; src += 8;\n      }\n      if (n & 4) {\n        store<u32>(dest, load<u32>(src));\n        dest += 4; src += 4;\n      }\n      if (n & 2) { // drop to 2 bytes each\n        store<u16>(dest, load<u16>(src));\n        dest += 2; src += 2;\n      }\n      if (n & 1) { // drop to 1 byte\n        store<u8>(dest++, load<u8>(src++));\n      }\n      return;\n    }\n\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\n    if (n >= 32) {\n      switch (dest & 3) {\n        // known to be != 0\n        case 1: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 3;\n          while (n >= 17) {\n            x = load<u32>(src + 1);\n            store<u32>(dest, w >> 24 | x << 8);\n            w = load<u32>(src + 5);\n            store<u32>(dest + 4, x >> 24 | w << 8);\n            x = load<u32>(src + 9);\n            store<u32>(dest + 8, w >> 24 | x << 8);\n            w = load<u32>(src + 13);\n            store<u32>(dest + 12, x >> 24 | w << 8);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 2: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 2;\n          while (n >= 18) {\n            x = load<u32>(src + 2);\n            store<u32>(dest, w >> 16 | x << 16);\n            w = load<u32>(src + 6);\n            store<u32>(dest + 4, x >> 16 | w << 16);\n            x = load<u32>(src + 10);\n            store<u32>(dest + 8, w >> 16 | x << 16);\n            w = load<u32>(src + 14);\n            store<u32>(dest + 12, x >> 16 | w << 16);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 3: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          n -= 1;\n          while (n >= 19) {\n            x = load<u32>(src + 3);\n            store<u32>(dest, w >> 8 | x << 24);\n            w = load<u32>(src + 7);\n            store<u32>(dest + 4, x >> 8 | w << 24);\n            x = load<u32>(src + 11);\n            store<u32>(dest + 8, w >> 8 | x << 24);\n            w = load<u32>(src + 15);\n            store<u32>(dest + 12, x >> 8 | w << 24);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n      }\n    }\n\n    // copy remaining bytes one by one\n    if (n & 16) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 8) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 4) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 2) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 1) {\n      store<u8>(dest++, load<u8>(src++));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","export function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var result: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  while (len && !(result = <i32>load<u16>(ptr1) - <i32>load<u16>(ptr2))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: i32): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  // @ts-ignore: cast\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isWhiteSpaceOrLineTerminator(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    // @ts-ignore: cast\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    // @ts-ignore: cast\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    return <T>NaN;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\n// FIXME: naive implementation\nexport function strtod(str: string): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str);\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  var sign = 1.0;\n  // trim white spaces\n  while (isWhiteSpaceOrLineTerminator(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n    sign = -1.0;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // calculate value\n  var num = 0.0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = num * 10 + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  subarray(start: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var length = array.length;\n  start = start < 0 ? max(length + start, 0) : min(start, length);\n  end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var length = array.length;\n  if (length <= 1) return array;\n  var base = array.dataStart;\n  if (length == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, length, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = <i32>array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n  var out = changetype<TArray>(__alloc(offsetof<TArray>(), idof<TArray>())); // retains\n  out.data = array.data; // retains\n  out.dataStart = array.dataStart + (<usize>begin << alignof<T>());\n  out.dataLength = (end - begin) << alignof<T>();\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var dataStart = array.dataStart;\n  var out = instantiate<TArray>(length);\n  var outDataStart = out.dataStart;\n  for (let i = 0; i < length; i++) {\n    store<T>(\n      outDataStart + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n","import { Address } from \"./address\";\nimport { getSelf, getSender, getReciver } from \"../internal/account.d\";\nimport { Account } from \"./account\";\nimport { Action } from \"./action\";\nimport { Transaction } from \"./transaction\";\n\nexport class Contract {\n    sender: Address;\n    receiver: Address;\n    contract: Address;\n    actionName: string;\n\n    constructor() {\n        let _contract = new Bytes(20);\n        getSelf(changetype<usize>(_contract.buffer));\n        this.contract = new Address(_contract);\n        let _sender = new Bytes(20);\n        getSender(changetype<usize>(_sender.buffer));\n        this.sender = new Address(_sender);\n        let _receiver = new Bytes(20);\n        getReciver(changetype<usize>(_receiver.buffer));\n        this.receiver = new Address(_receiver);\n        this.actionName = Action.getActionName();\n    }\n\n    isAction(actionName: string): bool {\n        return actionName == this.actionName;\n    }\n\n    getDataStream(): DataStream {\n        return Action.getActionData();\n    }\n\n    // static get txHash() {\n    //     return Transaction.getTxHash();\n    // }\n\n\n}","export class Address implements Serializable {\n\t_value: Bytes;\n\t_len: u32 = 20;\n\n\tstatic from(hex: string): Address {\n\t\treturn new Address(Bytes.fromHex(hex));\n\t}\n\n\tconstructor(raw: Bytes) {\n\t\tif (raw.length > 20) {\n\t\t\traw = <Bytes>(<Uint8Array>raw.subarray(0, 20));\n\t\t}\n\t\tthis._value = raw;\n\t}\n\n\thex(): string {\n\t\treturn this._value.toString();\n\t}\n\n\t@operator(\"==\")\n\tequal(t: Address): bool {\n\t\tfor (let i = 0; i < this._len; i++) {\n\t\t\tif (this._value[i] !== t._value[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@operator(\"!=\")\n\tnotEqual(t: Address): bool {\n\t\treturn !this.equal(t);\n\t}\n\n\tget bytes(): Bytes {\n\t\treturn this._value;\n\t}\n\n\tget buffer(): usize {\n\t\treturn changetype<usize>(this._value.buffer);\n\t}\n\n\tserialize(ds: DataStream): void {\n\t\tds.writeVector<u8>(this._value.toU8Array());\n\t}\n\n\tdeserialize(ds: DataStream): void {\n\t\tconst arr = ds.readVector<u8>();\n\t\tthis._value = Bytes.fromU8Array(arr);\n\t}\n\n\tkey(): string {\n\t\treturn \"\";\n\t}\n}","import { Address } from \"./address\";\nimport { Assert } from \"./system\";\nimport { RIPEMD160_LEN, SHA256_LEN, SHA512_LEN } from \"../lib/constant\";\nimport { getActionName, getActionData, hasAuth, requireAuth, callAction, returnData, returnU64, getValue } from \"../internal/action.d\";\nimport { EncodeSLEB128, EncodeULEB128, StringToUsize } from \"../lib/codec\";\nimport { CreateDataStream, } from \"../lib/helper\";\nimport { Asset, UNIT } from \"./asset\";\n\n/**\n * Builtin represents a parameter with built-in type.\n * Only support 'bool','int8','uint8','int16','uint16','int32','uint32','int64','uint64',\n * 'varint32','varuint32','address','publicKey','signature'\n */\nexport class Builtin implements Serializable {\n  _val: Bytes;\n\n  constructor(val: Bytes) { this._val = val; }\n\n  static fromI32(val: i32): Builtin {\n    return Builtin.fromU32(val);\n  }\n\n  static fromU32(val: u32): Builtin {\n    let bytes = new Bytes(4);\n    let i = 0;\n    while (i < bytes.length) {\n      let c: u8 = (val >> (i * 8)) & 0xff;\n      bytes[i] = c;\n    }\n    return new Builtin(bytes);\n  }\n\n  static fromI64(val: i64): Builtin {\n    return Builtin.fromU64(val);\n  }\n\n  static fromU64(val: u64): Builtin {\n    let bytes = new Bytes(8);\n    let i = 0;\n    while (i < bytes.length) {\n      let c: u8 = (val >> (i * 8)) & 0xff;\n      bytes[i] = c;\n    }\n    return new Builtin(bytes);\n  }\n\n  static fromI8(val: i8): Builtin {\n    return Builtin.fromU8(val);\n  }\n\n  static fromU8(val: u8): Builtin {\n    let bytes = new Bytes(1);\n    bytes[0] = val;\n    return new Builtin(bytes);\n  }\n\n  static fromI16(val: i16): Builtin {\n    return Builtin.fromU16(val);\n  }\n\n  static fromU16(val: u16): Builtin {\n    let bytes = new Bytes(2);\n    let i = 0;\n    while (i < bytes.length) {\n      let c: u8 = (val >> (i * 8)) & 0xff;\n      bytes[i] = c;\n    }\n    return new Builtin(bytes);\n  }\n\n  // Encode a Signed LEB128 variable-length integer to bytes.\n  static fromVari32(val: i32): Builtin {\n    return new Builtin(EncodeSLEB128(val));\n  }\n\n  // Encode a LEB128 variable-length integer to bytes.\n  static fromVaru32(val: u32): Builtin {\n    return new Builtin(EncodeULEB128(val));\n  }\n\n  static fromAddress(addr: Address): Builtin {\n    return new Builtin(addr.bytes())\n  }\n\n  static fromString(str: string): Builtin {\n    return new Builtin(Bytes.fromString(str));\n  }\n\n  static fromBytes(bytes: Bytes): Builtin {\n    return new Builtin(bytes);\n  }\n\n  static fromHash160(bytes: Bytes): Builtin {\n    Assert(bytes.length == RIPEMD160_LEN, 'invalid Hash160 length');\n    return new Builtin(bytes);\n  }\n\n  static fromHash256(bytes: Bytes): Builtin {\n    Assert(bytes.length == SHA256_LEN, 'invalid Hash256 length');\n    return new Builtin(bytes);\n  }\n\n  static fromHash512(bytes: Bytes): Builtin {\n    Assert(bytes.length == SHA512_LEN, 'invalid Hash512 length');\n    return new Builtin(bytes);\n  }\n\n  bytes(): Bytes {\n    return this._val;\n  }\n\n  len(): i32 {\n    return this._val.length;\n  }\n\n  serialize(ds: DataStream): void {\n    const arr = this._val.toU8Array();\n    ds.writeVector<u8>(arr);\n  }\n\n  deserialize(ds: DataStream): void {\n    const arr = ds.readVector<u8>();\n    this._val = Bytes.fromU8Array(arr);\n  }\n\n  key(): string {\n    return \"\";\n  }\n}\n\n/**\n * BuiltinArray represents an array of parameters with built-in types,\n * like 'string[]', 'u64[]'\n * \n */\nexport class BuiltinArray extends Array<Builtin> implements Serializable {\n  serialize(ds: DataStream): void {\n    ds.writeComplexVector<Builtin>(this);\n  }\n\n  deserialize(ds: DataStream): void {\n    const arr = ds.readComplexVector<Builtin>();\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n\n  key(): string {\n    return \"\";\n  }\n}\n\nexport class Action implements Serializable {\n  _to: Address;\n  _value: Asset;\n  _method: string;\n  _payload: Serializable[];\n  _extra: string;\n\n  constructor(to: Address, value: Asset, method: string, payload?: Serializable[], extra?: string) {\n    this._to = to;\n    this._value = value;\n    this._method = method;\n    this._payload = payload || [];\n    this._extra = extra || \"\";\n  }\n\n  static getActionName(): string {\n    const size = getActionName(0, 0);\n    const bytes = new Bytes(size);\n    getActionName(changetype<usize>(bytes.buffer), size);\n    return bytes.toString();\n  }\n\n  static getActionData(): DataStream {\n    const size = getActionData(0, 0);\n    const ds = CreateDataStream(size)\n    getActionData(ds.buffer, ds.len);\n    return ds;\n  }\n\n  static getValue(): Asset {\n    const size = getValue(0, 0);\n    const ds = CreateDataStream(size);\n    getValue(ds.buffer, ds.len);\n    const amount = ds.read<u64>();\n    return new Asset(amount, UNIT);\n  }\n\n  send(): void {\n    Assert(this._method != \"__DEPLOY__\", \"action name should not be '__DEPLOY__'\");\n    const size = DataStream.measure<Action>(this);\n    const ds = CreateDataStream(size)\n    this.serialize(ds);\n    callAction(ds.buffer, ds.len);\n  }\n\n  serialize(ds: DataStream): void {\n    // fill _to address\n    this._to.serialize(ds);\n    // fill the u64 value\n    this._value.serialize(ds);\n    // fill the method of action\n    ds.writeString(this._method);\n    let payloadSize: u64 = 0;\n    // fill serialized payload field\n    for (let i = 0; i < this._payload.length; i++) {\n      const param = this._payload[i];\n      if (param instanceof Builtin) {\n        payloadSize += DataStream.measure<Builtin>(param)\n      } else if (param instanceof BuiltinArray) {\n        payloadSize += DataStream.measure<BuiltinArray>(param);\n      } else {\n        throw new Error(\"unknown parameters type\");\n      }\n    }\n    ds.write<u64>(payloadSize);\n    for (let i = 0; i < this._payload.length; i++) {\n      this._payload[i].serialize(ds);\n    }\n    // fill extra field\n    ds.writeString(this._extra);\n  }\n\n  deserialize(ds: DataStream): void {\n    return;\n  }\n\n  key(): string {\n    return \"\";\n  }\n}\n\n/**\n * Verifies and returns whether the address is the sender.\n * \n * @param addr - address of a certain account\n */\nexport function HasAuth(addr: Address): bool {\n  return hasAuth(addr.buffer);\n}\n\n/**\n * Verifies the given address is the sender and throw error if not.\n * \n * @param addr - address of a certain account\n */\nexport function RequireAuth(addr: Address): void {\n  return requireAuth(addr.buffer);\n}\n\n/**\n * Set bytes as return data of action.\n * \n * @param bytes - bytes array\n */\nexport function ReturnBytes(bytes: Bytes): void {\n  returnData(changetype<usize>(bytes.buffer), bytes.length);\n}\n\n/**\n * Set string as return data of action.\n * \n * @param str - a string\n */\nexport function ReturnString(str: string): void {\n  returnData(StringToUsize(str), str.length);\n}\n\n/**\n * Set uint64 value as return data of action.\n * \n * @param v - u64 value\n */\nexport function ReturnU64(v: u64): void {\n  returnU64(v);\n}","import { DataStream } from \"./datastream\"\n\nexport class Bytes extends Uint8Array {\n    static fromHex(hex: string): Bytes {\n        if (hex.substr(0, 2) == \"0x\") {\n            hex = hex.substr(2);\n        }\n\n        let len = hex.length % 2 == 0 ? hex.length / 2 : hex.length / 2 + 1\n        let bytes = new Bytes(len);\n        let i = 0;\n        while (hex.length) {\n            let shex = hex.substr(hex.length - 2, hex.length);\n            bytes[i++] = parseInt(shex, 16);\n            hex = hex.substr(0, hex.length - 2);\n        }\n\n        return bytes\n    }\n\n    static fromU8Array(arr: Array<u8>): Bytes {\n        let bytes = new Bytes(arr.length);\n        for (let i = 0; i < arr.length; i++) {\n            bytes[i] = arr[i]\n        }\n        return bytes;\n    }\n\n    static fromString(str: string): Bytes {\n        const bytes = new Bytes(str.length)\n        const buffer = String.UTF8.encode(str)\n\n        memory.copy(changetype<usize>(bytes.buffer), changetype<usize>(buffer), buffer.byteLength);\n        return bytes;\n    }\n\n    toHex(): string {\n        let b = this;\n        let hexTable = \"0123456789abcdef\".split('');\n        let hex = \"\";\n        let rb = b.swapEndian()\n        for (let i = 0; i < rb.length; i++) {\n            let byte: u8 = rb[i];\n            hex += hexTable[byte >> 4]\n            hex += hexTable[byte & 0x0f]\n        }\n        return \"0x\" + hex;\n    }\n\n\n    swapEndian(): Bytes {\n        let clone = this.cloneBytes();\n        return <Bytes>(clone.reverse());\n    }\n\n    cloneBytes(): Bytes {\n        let bytes = this;\n        let clone = new Bytes(bytes.length);\n        for (let i = 0; i < bytes.length; i++) {\n            clone[i] = bytes[i]\n        }\n        return clone;\n    }\n\n    toU8Array(): Array<u8> {\n        let bytes = this;\n        const arr = new Array<u8>(bytes.length)\n        for (let i = 0; i < bytes.length; i++) {\n            arr[i] = bytes[i];\n        }\n        return arr;\n    }\n\n    // Concat two different bytes and returns a new bytes.\n    concat(b2: Bytes): Bytes {\n        let b1 = this;\n        const newBytes = new Array<u8>();\n        for (let i = 0; i < b1.length; i++) {\n            newBytes.push(b1[i])\n        }\n        for (let i = 0; i < b2.length; i++) {\n            newBytes.push(b2[i])\n        }\n        return Bytes.fromU8Array(newBytes);\n    }\n\n    wrapDataStream(): DataStream {\n        let bytes = new Bytes(this.length);\n        let ds = new DataStream(changetype<usize>(bytes.buffer), this.length);\n        ds.writeVector<u8>(this.toU8Array());\n        return ds;\n    }\n\n    toString(): string {\n        let bytes = this;\n        return String.UTF8.decode(bytes.buffer);\n    }\n\n}\n","/**\n * printable characters.\n */\nexport const ASCIICHAR: string[/*95*/] = [\n    \" \", \"!\", \"\\\"\", \"#\", \"$\", \"%\", \"&\", \"'\",\n    \"(\", \")\", \"*\", \"+\", \",\", \"-\", \".\", \"/\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n    \"8\", \"9\", \":\", \";\", \"<\", \"=\", \">\", \"?\",\n    \"@\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\",\n    \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\",\n    \"P\", \"Q\", \"R\", \"R\", \"T\", \"U\", \"V\", \"W\",\n    \"X\", \"Y\", \"Z\", \"[\", \"\\\\\", \"]\", \"^\", \"_\",\n    \"`\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n    \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\",\n    \"x\", \"y\", \"z\", \"{\", \"|\", \"}\", \"~\"];\n/**\n * convert an uint64 to string.\n * @param _int uint64 to convert\n * @returns string\n */\nexport function intToString(_int: u64): string {\n    var remainder: i32 = <i32>(_int % 10);\n    var rest: u64 = _int / 10;\n    var val: string = ASCIICHAR[16 + remainder];\n\n    while (rest != 0) {\n        remainder = <i32>(rest % 10);\n        rest = rest / 10;\n\n        val = ASCIICHAR[16 + remainder] + val;\n    }\n\n    return val;\n}\n/**\n * convert an utf-16 to utf-8 string array.\n * @param str a typescript string\n *\n * @returns an array of uint8\n */\nexport function toUTF8Array(str: string): u8[] {\n    var utf8: u8[] = new Array<u8>();\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(<u8>charcode);\n        else if (charcode < 0x800) {\n            utf8.push(<u8>(0xc0 | (charcode >> 6)));\n            utf8.push(<u8>(0x80 | (charcode & 0x3f)));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(<u8>(0xe0 | (charcode >> 12)));\n            utf8.push(<u8>(0x80 | ((charcode >> 6) & 0x3f)));\n            utf8.push(<u8>(0x80 | (charcode & 0x3f)));\n        }\n        // surrogate pair\n        else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff) << 10)\n                | (str.charCodeAt(i) & 0x3ff));\n            utf8.push(<u8>(0xf0 | (charcode >> 18)));\n            utf8.push(<u8>(0x80 | ((charcode >> 12) & 0x3f)));\n            utf8.push(<u8>(0x80 | ((charcode >> 6) & 0x3f)));\n            utf8.push(<u8>(0x80 | (charcode & 0x3f)));\n        }\n    }\n    utf8.push(<u8>0x00);\n    return utf8;\n}\n/**\n * convert string to usize.\n * here, <i>usize</i> likes <i>\"const char*\"</i> in c/c++.\n * @param str a utf-16 string of typescript.\n *\n * @returns usize\n */\nexport function string2cstr(str: string): u32 {\n    var cstr = toUTF8Array(str);\n    var ptr: u32 = load<u32>(changetype<usize>(cstr));\n    return <usize>ptr + sizeof<u64>();\n}\n\nfunction char_to_symbol(c: u8): u64 {\n    if (c >= 97 && c <= 122)\n        return (c - 97) + 6;\n    if (c >= 49 && c <= 53)\n        return (c - 49) + 1;\n    return 0;\n}\n/**\n * convert a string to uint64 encoded by Base32.\n * so the string must follow below principles:\n * 1. no more than 13 characters.\n * 2. only contains \".12345abcdefghijklmnopqrstuvwxyz\"\n * 3. not end with \".\"\n *\n * @param str string to convert\n */\nexport function N(str: string): u64 {\n    var len: u32 = str.length;\n    var value: u64 = 0;\n\n    for (let i: u32 = 0; i <= 12; ++i) {\n        let c: u64 = 0;\n        // let chrcode: u8 = <u8>(str.charCodeAt(i & 0xff));\n        if (i < len && i <= 12) {\n            c = <u64>char_to_symbol(<u8>(str.charCodeAt(i) & 0xff));\n        }\n\n        if (i < 12) {\n            c &= 0x1f;\n            c <<= 64 - 5 * (i + 1);\n        } else {\n            c &= 0x0f;\n        }\n\n        value |= c;\n    }\n\n    return value;\n}\n/**\n * a revert operation of method <i>N</i>\n *\n * @param name uint64 value\n */\nexport function RN(name: u64): string {\n    const charmap: string = \".12345abcdefghijklmnopqrstuvwxyz\";\n    const DOT: u8 = <u8>(0x2e);\n    let strcodes: u8[/*13*/] = [DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT, DOT];\n\n    let tmp: u64 = name;\n    for (let i: u32 = 0; i <= 12; ++i) {\n        let idx: i32 = <i32>(tmp & (i == 0 ? 0x0f : 0x1f));\n        let code: u8 = <u8>charmap.charCodeAt(idx) & 0xff;\n        strcodes[12 - i] = code;\n        tmp >>= (i == 0 ? 4 : 5);\n    }\n\n    let str: string = \"\";\n    let skipDot: boolean = true;\n    for (let i: i32 = 12; i >= 0; --i) {\n        if (strcodes[i] == DOT && skipDot) {\n            // skip right pending dots\n        } else {\n            skipDot = false;\n            let charIdx = strcodes[i] - 0x20;\n            str = ASCIICHAR[charIdx] + str;\n        }\n    }\n    return str;\n}\n\nexport function NameSuffix(n: u64): u64 {\n    let remaining_bits_after_last_actual_dot: u32 = 0;\n    let tmp: u32 = 0;\n\n    for (let remaing_bits: i32 = 59; remaing_bits >= 4; remaing_bits -= 5) {\n        let c: u64 = (n >> remaing_bits) & 0x000000000000001F; /* 64 bits */\n        if (c == 0) {\n            tmp = <u32>remaing_bits;\n        } else {\n            remaining_bits_after_last_actual_dot = tmp;\n        }\n    }\n\n    let thirteenth_character: u64 = n & 0x000000000000000F;\n    if (thirteenth_character != 0) {\n        remaining_bits_after_last_actual_dot = tmp;\n    }\n\n    if (remaining_bits_after_last_actual_dot == 0) return n; // no actual dot in the name except leading dots.\n\n    let mask: u64 = (0x0000000000000001 << remaining_bits_after_last_actual_dot) - 16;\n    let shift = 64 - remaining_bits_after_last_actual_dot;\n    return (((n & mask) << shift) + (thirteenth_character << (shift - 1)));\n}\n","import { toUTF8Array } from \"./utf8util\";\nimport { Serializable } from \"./serializable\";\nimport { Uint8Array } from \"typedarray\";\n/**\n * internal memory HEADER SIZE. NEVER used by users.\n */\nconst HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n\n/**\n * internal class, not for external users.\n */\n\n\n\nexport class DSHelper {\n    static serializeComplexVector<T extends Serializable>(arr: T[]): DataStream {\n        let len = DataStream.measureComplexVector<T>(arr);\n        let data = new Uint8Array(len);\n        let ds = new DataStream( changetype<usize>(data.buffer), len);\n        ds.writeComplexVector<T>(arr);\n        return ds;\n    }\n\n    static serializeComplex<T extends Serializable>(t: T): DataStream {\n        let len = DataStream.measure<T>(t);\n        let data = new Uint8Array(len);\n        let ds = new DataStream(changetype<usize>(data.buffer), len);\n        t.serialize(ds);\n        return ds;\n    }\n\n    static getDataStreamWithLength(len: u32): DataStream {\n        let arr = new Uint8Array(len);\n        let ds = new DataStream(changetype<usize>(arr.buffer), len);\n        return ds;\n    }\n}\n/**\n * internal class, not for external users.\n *\n * @class DataStream\n */\nexport class DataStream {\n    buffer: u32;\n    len: u32;\n    pos: u32;\n\n    /**\n     * make a DataStream from an existing array.\n     * @param from an array of basic class, like u8/i8, u16/i16, u32/i32, u64/i64\n     */\n    static fromArray<T>(from: T[]): DataStream {\n        let len: u32 = <u32>from.length;\n        let bytes = len * sizeof<T>();\n        let arr = new Uint8Array(bytes);\n        let ds = new DataStream(changetype<usize>(arr.buffer), bytes);\n        for (let i: u32 = 0; i < len; i++) {\n            ds.write<T>(from[i]);\n        }\n        ds.pos = 0;\n        return ds;\n    }\n\n    /**\n     * to measure the length of serialized buffer.\n     * @param obj an instance of class which implements Serializable.\n     */\n    static measure<T extends Serializable>(obj: T): u32 {\n        let ins = new DataStream(0, 0);\n        obj.serialize(ins);\n\n        return ins.pos;\n    }\n\n    static measureComplexVector<T extends Serializable>(arr: T[]): u32 {\n        let ins = new DataStream(0, 0);\n        let len: u32 = <u32>arr.length;\n        ins.writeVarint32(len);\n        for (let i: u32 = 0; i < len; i++) {\n            arr[i].serialize(ins);\n        }\n        return ins.pos;\n    }\n\n    constructor(buffer: u32, len: u32) {\n        this.buffer = buffer;\n        this.len = len;\n        this.pos = 0;\n    }\n\n    private isMeasureMode(): boolean {\n        return this.buffer == 0;\n    }\n\n    pointer(): usize {\n        return <usize>this.buffer;\n    }\n\n    size(): u32 {\n        if (this.isMeasureMode()) return this.pos;\n        else return this.len;\n    }\n\n    readVarint32(): u32 {\n        var value: u32 = 0;\n        var shift: u32 = 0;\n        do {\n            var b = this.read<u8>();\n            value |= <u32>(b & 0x7f) << (7 * shift++);\n        } while (b & 0x80);\n        return value;\n    }\n\n    writeVarint32(value: u32): void {\n        do {\n            let b: u8 = <u8>value & <u8>0x7f;\n            value >>= 7;\n            b |= ((value > 0 ? 1 : 0) << 7);\n            this.write<u8>(b);\n        } while (value);\n    }\n\n    write<T>(value: T): void {\n        if (!this.isMeasureMode()) {\n            store<T>(this.buffer + this.pos, value);\n        }\n        this.pos += sizeof<T>();\n    }\n\n    read<T>(): T {\n        let value: T = load<T>(this.buffer + this.pos);\n        this.pos += sizeof<T>();\n        return value;\n    }\n\n    toArray<T>(): T[] {\n        if (this.len == 0) return new Array<T>();\n\n        let len = this.len / sizeof<T>();\n        let arr = new Array<T>(len);\n        let idx = 0;\n        for (let i: u32 = 0; i < len; i++) {\n            let value: T = load<T>(this.buffer + idx);\n            arr[i] = value;\n            idx += sizeof<T>();\n        }\n        return arr;\n    }\n\n    readStringVector(): string[] {\n        let len = this.readVarint32();\n        if (len == 0) return new Array<string>();\n\n        let arr = new Array<string>(len);\n        for(let i: u32 = 0; i < len; i++) {\n            arr[i] = this.readString();\n        }\n        return arr;\n    }\n\n    writeStringVector(arr: string[]): void {\n        let len: u32 = arr.length;\n        this.writeVarint32(len);\n        for (let i: u32 = 0; i < len; i++) {\n            this.writeString(arr[i]);\n        }\n    }\n\n    readVector<T>(): T[] {\n        let len = this.readVarint32();\n        if (len == 0) return new Array<T>();\n\n        let arr = new Array<T>(len);\n        for (let i: u32 = 0; i < len; i++) {\n            // arr[i] = {} as T;\n            arr[i] = this.read<T>();\n        }\n\n        return arr;\n    }\n\n    writeVector<T>(arr: T[]): void {\n        let len: u32 = <u32>arr.length;\n        this.writeVarint32(len);\n        for (let i: u32 = 0; i < len; i++) {\n            this.write<T>(arr[i]);\n        }\n    }\n\n    /**\n     * read array of complex class which implements Serializable interface.\n     */\n    readComplexVector<T extends Serializable>(): T[] {\n        let len = this.readVarint32();\n        if (len == 0) return new Array<T>();\n\n        let arr = new Array<T>(len);\n        for (let i: u32 = 0; i < len; i++) {\n            arr[i] = {} as T;\n            arr[i].deserialize(this);\n        }\n        return arr;\n    }\n\n    /**\n     * write array of complex class which implements ISerialzable interface.\n     */\n    writeComplexVector<T extends Serializable>(arr: T[]): void {\n        let len: u32 = <u32>arr.length;\n        this.writeVarint32(len);\n        for (let i: u32 = 0; i < len; i++) {\n            arr[i].serialize(this);\n        }\n    }\n\n    readString(): string {\n        var len = this.readVarint32();\n        if (len == 0) return \"\";\n\n        var data = new Uint8Array(len);\n        memory.copy(changetype<usize>(data.buffer), this.buffer + this.pos, len);\n        this.pos += len;\n        return String.UTF8.decodeUnsafe(changetype<usize>(data.buffer), len );\n    }\n\n    writeString(str: string): void {\n        var len = String.UTF8.byteLength(str);\n        this.writeVarint32(len);\n        if (len == 0) return;\n\n        if (!this.isMeasureMode()) {\n            let ptr = changetype<usize>(str);\n            memory.copy(this.buffer + this.pos, <usize>ptr, len);\n        }\n        this.pos += len;\n    }\n\n    writeDouble(d: f64): void {}\n    readDouble(): f64 { return 0.0; }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isWhiteSpaceOrLineTerminator } from \"./util/string\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { idof } from \"./builtins\";\n\n@sealed export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\n\n  static fromCharCode(unit: i32, surr: i32 = -1): string {\n    var out: usize;\n    if (~surr) {\n      out = __alloc(4, idof<string>());\n      store<u16>(out, <u16>unit);\n      store<u16>(out, <u16>surr, 2);\n    } else {\n      out = __alloc(2, idof<string>());\n      store<u16>(out, <u16>unit);\n    }\n    return changetype<string>(out); // retains\n  }\n\n  static fromCodePoint(code: i32): string {\n    assert(<u32>code <= 0x10FFFF);\n    var sur = code > 0xFFFF;\n    var out = __alloc((i32(sur) + 1) << 1, idof<string>());\n    if (!sur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(out, (hi << 16) | lo);\n    }\n    return changetype<string>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = __alloc(resultLength << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + intStart, resultLength);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    len = toPos - fromPos;\n    if (!len) return changetype<String>(\"\");\n    if (!fromPos && toPos == this.length << 1) return this;\n    var out = __alloc(len, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, len);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var length = this.length;\n    var size: usize = length << 1;\n    while (\n      size &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + size)\n      )\n    ) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (\n      offset < size &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + offset)\n      )\n    ) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!start && size == length << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (\n      offset < size &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + offset)\n      )\n    ) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (\n      size &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + size)\n      )\n    ) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = __allocArray(length, alignof<String>(), idof<Array<String>>());\n      let resultStart = changetype<ArrayBufferView>(result).dataStart;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return changetype<Array<String>>(result); // retains\n    } else if (!length) {\n      let result = __allocArray(1, alignof<String>(), idof<Array<String>>());\n      store<usize>(changetype<ArrayBufferView>(result).dataStart, changetype<usize>(\"\")); // static \"\"\n      return changetype<Array<String>>(result); // retains\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return changetype<Array<String>>(result); // retains\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return changetype<Array<String>>(result); // retains\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return changetype<Array<String>>(result); // retains\n    // releases result\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = nullTerminated ? 1 : 0;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          bufLen += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          bufLen += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              strOff += 4; bufLen += 4;\n              continue;\n            }\n          }\n          strOff += 2; bufLen += 3;\n        }\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var strOff = changetype<usize>(str);\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(UTF8.byteLength(str, nullTerminated), idof<ArrayBuffer>());\n      var bufOff = buf;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          store<u8>(bufOff, c1);\n          bufOff += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          store<u8>(bufOff, c1 >> 6      | 192);\n          store<u8>(bufOff, c1      & 63 | 128, 1);\n          bufOff += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            let c2 = <u32>load<u16>(strOff, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n              store<u8>(bufOff, c1 >> 18      | 240);\n              store<u8>(bufOff, c1 >> 12 & 63 | 128, 1);\n              store<u8>(bufOff, c1 >> 6  & 63 | 128, 2);\n              store<u8>(bufOff, c1       & 63 | 128, 3);\n              strOff += 4; bufOff += 4;\n              continue;\n            }\n          }\n          store<u8>(bufOff, c1 >> 12      | 224);\n          store<u8>(bufOff, c1 >> 6  & 63 | 128, 1);\n          store<u8>(bufOff, c1       & 63 | 128, 2);\n          strOff += 2; bufOff += 3;\n        }\n      }\n      if (nullTerminated) {\n        assert(strOff <= strEnd);\n        buf = __realloc(buf, bufOff - buf + 1);\n        store<u8>(bufOff, 0);\n      } else {\n        assert(strOff == strEnd);\n      }\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): string {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<string>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let cp = <u32>load<u8>(bufOff++);\n        if (cp < 128) {\n          if (nullTerminated && !cp) break;\n          store<u16>(strOff, cp);\n          strOff += 2;\n        } else if (cp > 191 && cp < 224) {\n          if (bufEnd - bufOff < 1) break;\n          store<u16>(strOff, (cp & 31) << 6 | load<u8>(bufOff++) & 63);\n          strOff += 2;\n        } else if (cp > 239 && cp < 365) {\n          if (bufEnd - bufOff < 3) break;\n          cp = (\n            (cp                  &  7) << 18 |\n            (load<u8>(bufOff)    & 63) << 12 |\n            (load<u8>(bufOff, 1) & 63) << 6  |\n             load<u8>(bufOff, 2) & 63\n          ) - 0x10000;\n          bufOff += 3;\n          store<u16>(strOff, 0xD800 + (cp >> 10));\n          store<u16>(strOff, 0xDC00 + (cp & 1023), 2);\n          strOff += 4;\n        } else {\n          if (bufEnd - bufOff < 2) break;\n          store<u16>(strOff,\n            (cp                  & 15) << 12 |\n            (load<u8>(bufOff)    & 63) << 6  |\n             load<u8>(bufOff, 1) & 63\n          );\n          bufOff += 2; strOff += 2;\n        }\n      }\n      return changetype<string>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var size = changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(size, idof<ArrayBuffer>());\n      memory.copy(buf, changetype<usize>(str), <usize>size);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): string {\n      var str = __alloc(len &= ~1, idof<string>());\n      memory.copy(str, buf, len);\n      return changetype<string>(str); // retains\n    }\n  }\n}\n","import { Contract } from \"../../index\";\nimport { Prints } from \"../../index\";\nimport { Printi, Printui } from \"../../index\";\nimport { PrintHex } from \"../../index\";\n\n@database(\"aaa\")\nclass Person{\n    age: u64 = 0;\n    \n    serialize(ds: DataStream) :void{\n        ds.write<u64>(this.age);\n    }\n\n    deserialize(ds:DataStream):void {\n        this.age = ds.read<u64>();\n    }\n\n    key():string {\n        return \"\";\n    }\n\n}\n\nclass printTest extends Contract{\n    @action\n    printActionName(a:Person): void{\n        Prints(this.actionName);\n    }\n\n    @action\n    printStr(msg: string): void{\n        Prints(msg);\n    }\n\n    @action\n    printInt(a: i64, b: u64): void{\n        Printi(a);\n        Printui(b);\n    }\n\n    @action\n    printAddr(): void{\n        PrintHex(this.contract.bytes);\n        PrintHex(this.receiver.bytes);\n        PrintHex(this.sender.bytes);\n    }\n}","export function CreateDataStream(size: u32): DataStream {\n  const bytes = new Bytes(size);\n  return new DataStream(changetype<usize>(bytes.buffer), size);\n}","import { prints, printi, printui, printHex } from \"../internal/print.d\";\nimport { StringToUsize } from \"../lib/codec\";\n\nexport function Prints(msg: string): void {\n  prints(StringToUsize(msg), msg.length);\n}\n\nexport function Printi(val: i64): void {\n  printi(val);\n}\n\nexport function Printui(val: u64): void {\n  printui(val);\n}\n\nexport function PrintHex(data: Bytes): void {\n  printHex(changetype<usize>(data.buffer), data.length);\n}","export function StringToUsize(str: string): usize {\n  return changetype<usize>(Bytes.fromString(str).buffer);\n}\n\n/**\n * EncodeULEB128 appends v to b using unsigned LEB128 encoding.\n */\nexport function EncodeULEB128(v: u64): Bytes {\n  const bytes = new Array<u8>();\n  while (1) {\n    let c: u8 = <u8>(v & 0x7f);\n    v >>= 7;\n    if (v != 0) {\n      c |= 0x80;\n    }\n    bytes.push(c);\n    if ((c & 0x80) == 0) {\n      break;\n    }\n  }\n  return Bytes.fromU8Array(bytes);\n}\n\n/**\n *  EncodeSLEB128 appends v to b using signed LEB128 encoding.\n */\nexport function EncodeSLEB128(v: i64): Bytes {\n  const bytes = new Array<u8>();\n  while (1) {\n    let c: u8 = <u8>(v & 0x7f);\n    let s: u8 = <u8>(v & 0x40);\n    v >>= 7;\n    if ((v != -1 || s == 0) && (v != 0 || s != 0)) {\n      c |= 0x80;\n    }\n    bytes.push(c);\n    if ((c & 0x80) == 0) {\n      break;\n    }\n  }\n  return Bytes.fromU8Array(bytes);\n}\n\n/** \n * DecodeULEB128 decodes bytes from stream with unsigned LEB128 encoding.\n */\nexport function DecodeULEB128(bytes: Bytes): u64 {\n  const ds = new DataStream(changetype<usize>(bytes.buffer), bytes.length);\n  let shift: u64 = 0;\n  let out: u64 = 0;\n  while (1) {\n    let b: u8 = ds.read<u8>();\n    out |= <u64>(b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      break;\n    }\n    shift += 7;\n  }\n\n  return out;\n}\n\n// DecodeSLEB128 decodes bytes from stream with signed LEB128 encoding.\nexport function DecodeSLEB128(bytes: Bytes): u64 {\n  const ds = new DataStream(changetype<usize>(bytes.buffer), bytes.length);\n  let shift: u64 = 0;\n  let out: u64 = 0;\n  while (1) {\n    let b: u8 = ds.read<u8>();\n    out |= <u64>(b & 0x7f) << shift;\n    shift += 7;\n    if ((b & 0x80) == 0) {\n      if ((b & 0x40) != 0) {\n        out |= ~0 << shift;\n      }\n      break;\n    }\n  }\n\n  return out;\n}"]}